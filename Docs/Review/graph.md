[TOC]
# 图算法
## 存储
### 邻接链表
- 存储容量$O(V+E)$
  - 有向图$O(V+2E)$
  - 无向图$O(V+E)$
- 查询某一条边是否存在
  - 遍历整个邻接链表$O(E)$
- 查询某一个顶的入/出度
  - 遍历该顶点整个链表$O(d_v)$
### 邻接矩阵
- 存储容量$O(V^2)$
## 搜索
### 广度优先搜索
- **给定源节点**
  - 使用邻接链表存储, 有
    - 时间复杂度$O(V + E)$
      - 每次取某个节点的所有邻居时, 只需要遍历整个链表
    - 空间复杂度$O(V+E)$
  - 使用邻接矩阵存储, 有
    - 时间复杂度$O(V^2)$
      - 每次去某个节点的所有邻居时, 需要遍历那个节点对应的行, 则有$O(V)$的复杂度, 同时一共重复$O(V)$次(**每个节点最多入队一次**)
### 深度优先搜索
- 白色路径定理
  - 如果$u,v$之间存在一条路径$p$, 满足$\forall a \in p, a.color=white$, 则$v$是$u$的后代 
- **给定源节点**
  - 使用邻接链表存储, 有
    - 时间复杂度$O(V+E)$
    - 空间复杂度$O(V+E)$, 递归调用显然小于$min\{V,E\}$
  - 使用邻接矩阵存储, 有
    - 时间复杂度$O(V^2)$？
- **不给定源节点, 对整个图进行`DFS`**
  - 使用邻接链表存储, 有
    - 时间复杂度$O(V+E)$
- 边的分类
  - $$树边\subset 后向边$$

#### 拓扑排序
- 将深度优先搜索得到的点, 按照**变黑的先后顺序**入链表(队列), 链表中的节点$v.f$从大到小
- 只能产生一个有向无环图的拓扑排序
- 时间复杂度$O(DFS)$
- 空间复杂度$O(V)$
#### 分解强联通分量
- 时间复杂度$O(DFS + V\lg V)$
  - 因为要对$v.f$排序, 然后在$G^T$上进行`DFS`
- 空间复杂度$O(取决于存储方式)$
#### 最小生成树和最短路径树
- 两者都包含原图的每个顶点
- 两者都是连通的
#### Prim算法, 克鲁斯卡尔算法
## 单源最短路径
- 最短路径上没有环路, 但图上可以有环路
### Bellman-Ford算法
- 功能
  - 如果图中有负权重的环, 输出false
  - 如果没有, 输出true, 同时每个节点的$v.d$都已经是$s$(源)到$v$的最短路径长度
- 细节
  - 对节点进行拓扑排序
  - 按此顺序对每个节点进行RELAX操作
- $O(V+E)$

### Dijkstra算法
- 功能
  - 每个节点的$v.d$都已经是$s$(源)到$v$的最短路径长度
- 细节
  - 每次从$V-S$中抽取出$v.d$最小的点加入$S$, 并更细$V-S$中每个点的$d$
- 复杂度
  - $O(E*T_{decrease key} + V*T_{extract min})$
  - 依赖于优先级队列的实现
  - 二项堆:$O((E+V)lgV)$
  - 斐波那契堆:$O(E+VlgV)$

## 所有点对的最短路径
### 重复平方法
### Floyd-Warshell算法
- 细节
  - 按照点来扩张路径, 而非按照矩阵
  - 不管是求距离长度还是回溯路径, 都只需要最后一个矩阵$D_{ij}^{(n)}$
- 时间复杂度
  - 最外层循环每次扩张一个点$k+1$；有$O(V)$
  - 内层两个循环遍历当前图上每个顶点之间最短路径, 更新；有$O(V^2)$
- 空间复杂度
  - 如果保存每个矩阵, 则需要$O(V^3)$
  - 如果只保存一个, 则$O(V^2)$

### Johnson算法
- 细节
  - 给边重新赋值, 保证没有负边:
    - $w'(i,j) = w(i,j) + h(u) - h(v)$
    - $h(u)$是使用`Bellman-Ford`算法求得的从新加入的虚拟节点$s$到$u$的单源最短路径
  - 用新权重对每个节点调用`Dijkstra`, 得到的伪最短路径$\delta'(i,j)$, 有$$\delta(i,j) = \delta'(i,j) + h(j) - h(i)$$
- 时间复杂度
  - 斐波那契堆: $O(VE+V^2lgV)$
  - 二项堆: $O(V^2lgV + VElgV)$
## 最大流
### 定义和定理
- 流的值$$|f| = \sum_{v\in V}f(s,v) = \sum_{v\in V}f(v,t)$$
- 