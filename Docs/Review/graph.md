[TOC]
# 图算法
## 搜索
### 广度优先搜索
- $O(V + E)$
### 深度优先搜索
- $O(V + E)$
#### 拓扑排序
- 将深度优先搜索得到的点, 按照变黑的先后顺序入链表(队列)
- $O(V + E)$
#### 最小生成树和最短路径树
- 两者都包含原图的每个顶点
- 两者都是连通的
#### Prim算法, 克鲁斯卡尔算法
## 单源最短路径
### Bellman-Ford算法
- 功能
  - 如果图中有负权重的环, 输出false
  - 如果没有, 输出true, 同时每个节点的$v.d$都已经是$s$(源)到$v$的最短路径长度
- 细节
  - 对节点进行拓扑排序
  - 按此顺序对每个节点进行RELAX操作
- $O(V+E)$

### Dijkstra算法
- 功能
  - 每个节点的$v.d$都已经是$s$(源)到$v$的最短路径长度
- 细节
  - 每次从$V-S$中抽取出$v.d$最小的点加入$S$, 并更细$V-S$中每个点的$d$
- 复杂度
  - $O(E*T_{decrease key} + V*T_{extract min})$
  - 依赖于优先级队列的实现
  - 二项堆:$O((E+V)lgV)$
  - 斐波那契堆:$O(E+VlgV)$

## 所有点对的最短路径
### 重复平方法
### Floyd-Warshell算法
- 细节
  - 按照点来扩张路径, 而非按照矩阵
  - 不管是求距离长度还是回溯路径, 都只需要最后一个矩阵$D_{ij}^{(n)}$
- 时间复杂度
  - 最外层循环每次扩张一个点$k+1$；有$O(V)$
  - 内层两个循环遍历当前图上每个顶点之间最短路径, 更新；有$O(V^2)$
- 空间复杂度
  - 如果保存每个矩阵, 则需要$O(V^3)$
  - 如果只保存一个, 则$O(V^2)$

### Johnson算法
- 细节
  - 给边重新赋值, 保证没有负边:
    - $w'(i,j) = w(i,j) + h(u) - h(v)$
    - $h(u)$是使用`Bellman-Ford`算法求得的从新加入的虚拟节点$s$到$u$的单源最短路径
  - 用新权重对每个节点调用`Dijkstra`, 得到的伪最短路径$\delta'(i,j)$, 有$$\delta(i,j) = \delta'(i,j) + h(j) - h(i)$$
- 时间复杂度
  - 斐波那契堆: $O(VE+V^2lgV)$
  - 二项堆: $O(V^2lgV + VElgV)$
## 最大流
### 定义和定理
- 流的值$$|f| = \sum_{v\in V}f(s,v) = \sum_{v\in V}f(v,t)$$
- 